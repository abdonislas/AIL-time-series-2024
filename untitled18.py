# -*- coding: utf-8 -*-
"""Untitled18.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W_balKe5db56xKVd4SPJm6LkBcQuze3Q
"""

import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
from statsforecast.models import AutoETS
from sklearn.metrics import mean_absolute_percentage_error

# Descargar datos mensuales de las 30 acciones en el índice IPC desde 2015
tickers = ["AMXL.MX", "GFNORTEO.MX", "CEMEXCPO.MX", "WALMEX.MX", "GMEXICOB.MX",
           "TLEVISACPO.MX", "BIMBOA.MX", "FEMSAUBD.MX", "ALSEA.MX", "KIMBERA.MX",
           "PINFRA.MX", "BOLSAA.MX", "PE&OLES.MX", "MEXCHEM.MX", "GCARSOA1.MX",
           "SANMEXB.MX", "GFINBURO.MX", "IENOVA.MX", "ARA.MX", "LALAB.MX",
           "LABB.MX", "GAPB.MX", "OMAB.MX", "ASURB.MX", "MEGACPO.MX",
           "ALFAA.MX", "KUOA.MX", "ELEKTRA.MX", "NEMAK.MX", "VALUEGFO.MX"]

# Crear un diccionario para almacenar los datos de cada ticker
data = {}
for ticker in tickers:
    df = yf.download(ticker, start="2015-01-01", end="2024-01-01", interval="1mo")["Adj Close"]
    df = df.dropna()  # Eliminar valores nulos
    data[ticker] = df

# Create a list to store the dataframes
dfs = []
for ticker in tickers:
    # Create a dataframe for each ticker
    df = pd.DataFrame(data[ticker])
    # Rename the column to the ticker symbol
    df = df.rename(columns={"Adj Close": ticker})
    # Add the dataframe to the list
    dfs.append(df)

# Concatenate the dataframes
df_prices = pd.concat(dfs, axis=1)

# Reindex to fill missing values with NaN and create a complete date range
df_prices = df_prices.reindex(
    pd.date_range(start=df_prices.index.min(), end=df_prices.index.max(), freq='MS')
)

split_index = int(len(df_prices) * 0.8)
train_data = df_prices[:split_index]
test_data = df_prices[split_index:]

# Ajustar el modelo ETS para cada acción
ets_models = {}
forecasts = {}
errors = {}

for ticker in tickers:
    # ... (your existing code) ...

    # Guardar modelo y predicción
    ets_models[ticker] = model
    # Changed to access 'mean' instead of 'value'
    forecasts[ticker] = model.predict(3)

    # Calcular error de pronóstico en el conjunto de prueba
    y_true = test_data[ticker].dropna().values
    # Change to access 'mean' from the forecasts dictionary
    y_pred = forecasts[ticker]['mean'].values[:len(y_true)] if len(y_true) <= 3 else forecasts[ticker]['mean'].values
    errors[ticker] = mean_absolute_percentage_error(y_true, y_pred)